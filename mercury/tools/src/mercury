#!/usr/bin/env python
# -*- coding: utf-8 -*-
from enum import Enum

import sys
import os

from pathlib import Path

sys.path.append(str(Path(__file__).parent.parent.parent.joinpath(Path('bindings/python'))))

from lxml import etree as ET

from mercury_nn import filter_validation
from mercury_nn.filter_validation import SyntaxValidationResult as FilterSyntaxValidationResult
from mercury_nn import manifest_validation
from mercury_nn.manifest_validation import SyntaxValidationResult as ManifestSyntaxValidationResult

from mercury_nn.specification.load_valid_usages import loadValidUsage
from mercury_nn.specification.load_filter_match_failure_specs import loadFilterMatchFailureSpecs

from mercury_nn.interface import FilterSyntaxInvalidityType, ManifestSyntaxInvalidityType, FilterMatchFailureType
from mercury_nn.config import Config

from mercury_nn.filtering import Filter, matchFilter

import argparse


class CommandTypes(Enum):
    VALIDATE_MANIFEST = "validate-manifest"
    VALIDATE_FILTER = "validate-filter"


# argparse
parser = argparse.ArgumentParser(description="Mercury Command-Line Utility")

subparsers = parser.add_subparsers(dest='command')

manifest_validation_subparser = subparsers.add_parser(
    CommandTypes.VALIDATE_MANIFEST,
    help='Validates a manifest.'
)

manifest_validation_subparser.add_argument('manifest_file', type=str)

filter_validation_subparser = subparsers.add_parser(
    CommandTypes.VALIDATE_FILTER,
    help='Validates a filter.'
)

filter_validation_subparser.add_argument('filter_file', type=str)

args = parser.parse_args()


# load valid usages
filter_syntax_valid_usages = loadValidUsage(filepath=Config.filterSyntaxValidUsageFile)
manifest_syntax_valid_usages = loadValidUsage(filepath=Config.manifestSyntaxValidUsageFile)

# validation
assert set(x for x in FilterSyntaxInvalidityType) == set(filter_syntax_valid_usages.keys())
assert set(x for x in ManifestSyntaxInvalidityType) == set(manifest_syntax_valid_usages.keys())

# load filter match failure specs
filter_match_failure_specs = loadFilterMatchFailureSpecs(filepath=Config.filterMatchFailureSpecsFile)

# validation
assert set(x for x in FilterMatchFailureType) == set(filter_match_failure_specs.keys())


def main(args) -> int:
    match args.command:
        case CommandTypes.VALIDATE_MANIFEST:
            try:
                with open(args.manifest_file, 'r') as f:
                    manifest_element = ET.parse(f)
                    manifest_element = manifest_element.getroot()
            except FileNotFoundError:
                print(f'File not found: {args.manifest_file}', file=sys.stderr)
                return 1

            # syntax validation
            syntax_validation_result = manifest_validation.checkSyntax(manifest_element)

            if not syntax_validation_result.isValid:
                # syntax is invalid
                invalidity_info = syntax_validation_result.invalidityInfo
                print(f'Manifest syntax valid usage violation detected at line {invalidity_info.invalidityPosition.line}: {invalidity_info.invalidityType}', file=sys.stderr)
                print(f'Description of valid usage: {manifest_syntax_valid_usages[invalidity_info.invalidityType].description}', file=sys.stderr)

                return 1
            
            # syntax is valid, match the manifest against base model
            try:
                with open(Config.baseModelFilterPath, 'r') as f:
                    filter_element = ET.parse(f)
                    filter_element = filter_element.getroot()
            except FileNotFoundError:
                print(f'File not found: {Config.baseModelFilterPath}', file=sys.stderr)
                
                return 1
            
            base_model_filter = Filter.fromXMLElement(filter_element)
            
            match_result = matchFilter(filterObject=base_model_filter, dataElement=manifest_element)

            if match_result.isSuccess:
                print('Manifest is valid.')

                return 0
            else:
                failure_info = match_result.failureInfo

                print(f'Manifest failed to match the base model filter at line {failure_info.failurePosition.filtereeLine} (manifest), {failure_info.failurePosition.filtererLine} (base model filter): {failure_info.failureType}', file=sys.stderr)
                print(f'Description of failure: {filter_match_failure_specs[failure_info.failureType].description}', file=sys.stderr)


        case CommandTypes.VALIDATE_FILTER:
            try:
                with open(args.filter_file, 'r') as f:
                    xml_element = ET.parse(f)
                    xml_element = xml_element.getroot()
            except FileNotFoundError:
                print(f'File not found: {args.filter_file}', file=sys.stderr)
                
                return 1
                    
            validation_result = filter_validation.checkFilterSyntax(xml_element)

            if validation_result.isValid:
                print('Filter is valid.')
                
                return 0
            else:
                invalidity_info = validation_result.invalidityInfo
                
                print(f'Valid usage violation detected at line {invalidity_info.invalidityPosition.line}: {invalidity_info.invalidityType}', file=sys.stderr)
                print(f'Description of valid usage: {filter_syntax_valid_usages[invalidity_info.invalidityType].description}', file=sys.stderr)

                return 1
                
        case _:
            print(f'Invalid command: {args.command}', file=sys.stderr)
            
            return 1


if __name__ == '__main__':
    return_code = main(args)
    exit(return_code)
